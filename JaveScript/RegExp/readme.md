# 正则表达式

- 正则表达式 regular expression 描述了 **字符串的“构成模式”**，经常被用于检查字符串是否符合预定的格式要求

## 构造正则表达式

1. 优先选用方法 `const regexp = /^m\d{3}n$/` /.../

2. 构造函数法 `const regexp = new RegExp('^m\\d{3}n$')` (内字符串)

3. 正则表达式的类型是 Regexp，但是 typeof 表示的是对象

```js
//说明
//^x 以x开头
//x$ 以x结尾
// /d表示是数字，{3}表示是3位数字
// 正则表达式，以位来计算
//使用
regexp.test("m123n"); // true
regexp.test("123"); //false
```

## 元字符

- 元字符 是指一位指定类型的字符
  1. \d 匹配一个数字
  2. \D 一个非数字
  3. \w 一个单字字符（字母、数字或者下划线）
  4. \W 一个非单字字符
  5. \s 一个空白字符，包括空格、制表符和换行符
  6. . 任意字符
  7. ^ 开头
  8. $ 结尾
  9. | 或 表示匹配指定几项之间的一项 只要匹配到其中一个就不会匹配后面的了

### 注意的地方

- 当使用 new RegExp()写法时，反斜杠需要多些一个

### 字符的转义

- 在特殊字符之前的反斜杠\表示下一个字符是不是特殊字符，应该按字面理解

```js
/^.$/   // 检查字符串是不是任意字符
/^\.$/  // 检查字符串是不是一个点
```

- 不管一个符号有没有特殊意义，都可以在其之前加上一个\以确保它表达的是不是这个符号本身

## 方括号表示法

- 使用方括号，比如[xyz]，可以创建一个**字符集合**，表示匹配方括号中的任意字符，

- 可以使用**短横-来指定一个字符的方位，^表示否定**

```
\d  =  [0-9]
\D  =  [^0-9]
\w  =  [A-Za-z0-9_]
\W  =  [^A-Za-z0-9_]
```

[练习](./2-9.js)

## 量词

```
*       匹配前一个表达式0次或者多次。等价于{0,}
+       匹配前面一个表达式1次或者多次。等价于{1,}
?       匹配前一个表达式0次或者1次。等价于{0,1}
{n}     n是一个正整数，匹配前面一个字符刚好出现了n次
{n,}    n是一个正整数，匹配前面一个字符至少出现了n次
{n,m}   n和m都是正整数，匹配前面的字符至少n次，最多m次
// 匹配几个字符的时候可以用圆括号扩起来(\.cn)? 有或者无
```

[练习](./2-12.js)

## 修饰符

- 修饰符也叫做标志 flags ， 用于使正则表达式实现高级搜索

```
i         不区分大小写搜索
g         全局搜索
```

- 使用

```js
const re = /m/gi;
const re = new RegExp("m", "gi");
```

## 正则表达式的相关方法

- 可以打点调用的方法

```js
test()              测试某字符串是否匹配正则表达式，返回布尔值
exec()              根据正则表达式，在字符串中进行查找，返回结果数组或者null
```

- `exec()`最有趣的是，**有“g”修饰符的正则表达式将自动成为“有状态”的**，意味着可以对单个字符串中的多次匹配结果进行**逐条的遍历**

[练习](./2-14.js)

## 字符串的相关方法

```js
search(); //在字符串中根据正则表达式进行查找匹配，返回首次匹配到的位置索引，测试不到则返回-1
match(); //在字符串中根据正则表达式进行查找匹配，返回一个数组，找不到则返回null
replace(); //使用替换字符替换匹配到的子字符串，可以使用正则表达式
split(); //分隔字符串位数组，可以使用正则表达式
```

[练习](./2-22.js)

## 正则表达式的应用

- 表单验证是最重要的实际应用

- 很多正则表达式不需要自己写，通过搜索引擎可以找到

[练习](./2-24.js)
