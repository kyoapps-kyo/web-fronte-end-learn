# ECMAScript6

- ES6 就是 ES2015 之后的版本

## let const 和 var 的区别

let 和 const 是 es6 之后提出来的，用来声明变量和常量

1. let 和 const 不能变量提升

2. 块级作用域

   - var 没有块级作用域

   ```js
   for (var i = 0; i < 3; i++) {}
   console.log(i); //3 i属于全局变量
   for (let j = 0; i < 3; i++) {}
   console.log(j); //报错
   ```

   - 作用域链

     - 只能由内往外，不能掉转方向
     - 内层作用域 -> 外层作用域 -> ... -> 全局作用域

   - 块级作用域种类

   ```js
   {
   }
   for(){}
   while(){}
   do{}while()
   if(){}
   switch(){}
   //对象的花括号不构成作用域
   //全局、块级作用域、函数作用域
   ```

## let const 的应用

- 主要是块级作用域的应用

```js
let btn = document.querySelectorAll(".btn");
for (let i = 0; i < 3; i++) {
  btn[i].addEventListener(
    "click",
    function () {
      console.log(i);
    },
    false
  );
}
//每次循环都会创建一个块级作用域，所以每个i都有单独的一个值
//使用var时，var定义的是全局变量，不管是不是在for循环里，最终i的值都会是循环结束时的值
//在es6之前，使用闭包解决这个问题
var btn2 = document.querySelectorAll(".btn");
for (var i = 0; i < 3; i++) {
  (function (index) {
    btn[index].addEventListener(
      "click",
      function () {
        console.log(index);
      },
      false
    );
  })(i);
}
//将i作为函数参数传给闭包函数的index，每次调用闭包函数，都会在内存中创建一个单独的index，所以每次调用的index都会不同
```

## 模版字符串

- 在模版字符串中可以使用`${变量名}`调用变量

```js
//输出多行字符串
//模版字符串中，所有的空格、换行或缩进都会保留在输出之中
const info = `line1
line2`;

//输出`和\等特殊字符
// \转义字符， \` \\ => ` \

//模版字符串的注入
// ${里面可以放什么}
// 只要最终可以得到一个值的就可以通过${}注入到模版字符串中
```

- 练习[2-7](./2-7.html)

## 箭头函数

- 箭头函数的注意事项

  1. 单个参数可以省略圆括号(无参数和多个参数不能省略圆括号)
  2. 如果函数体只有单行函数，可以同时去掉{}和 return（多行函数体就不能省略了）单行函数体省略了{}后，return 关键字也必须省略
  3. 如果函数返回的是一个对象{name：'Tim'}，可以使用圆括号包裹对象（{name：'Tim'}）,（）让其成为对象。

  ```js
  const add = (x, y) => ({ value: x + y }); //此时返回的是一个对象
  ```

### 箭头函数中的 this 指向问题

- 箭头函数没有 this

  - 按照 ES6 中的作用域链来对 this 进行查找

  - 箭头函数没有 this ，在箭头函数里面使用的 this 都是外层拥有 this 的作用域里的 this

  - 浏览器中，直接引用箭头函数，this 指向的是 window

  - 箭头函数没有自己的 this，无法实例化对象，也无法使用 call 方法等改变 this 指向，但可以沿着作用域链向外查找 this

- 在**严格模式**下，**本身指向 window 对象的 this 会变成 undefined**

```js
function foo() {
  return () => {
    return () => {
      return () => {
        console.log("id", this.id);
      };
    };
  };
}
var f = foo.call({ id: 1 });
var t1 = f.call({ id: 2 })()();
var t2 = f().call({ id: 3 })();
var t3 = f()().call({ id: 4 });
//这里面只有function foo有this，其余的所有的箭头函数都没有自己的this
//所以最终输出的结果都是id 1
```

## 不适用箭头函数的场景

1. 作为构造函数

2. 需要 this 指向调用函数的时候

3. 需要使用 arguments 的时候

- 在之前定时器中调用的函数的 this 指向的是 window，解决办法是在它的外层备份一个 self 或者 that，然后在定时器使用 self/that 调用对象的 this，现在我们可以尝试使用箭头函数没有 this 的特点，通过作用域链向外找 this 的特性，为定时器指定 this

- [3-12.html](./3-12.html)
- [3-14.html](./3-14.html)

# 解构赋值

## 数组的解构赋值

- const [a,b,c...] = [1,2,3...]

- 解析某一数据的解构，将我们想要的东西提取出来，赋值给变量或常量

### 解构赋值的原理

- 模式（结构）匹配

- 索引值相同的完成赋值

- 不取值的用“，”跳过

### 数组解构值的默认值

```js
// 当数组成员严格===undefined时，对应的默认值才会生效
const [a = 1, b = 2] = []; // 1，2
// 如果默认值是表达式，默认值表达式是惰性求值的
const fn = () => {
  console.log("我被执行了");
  return 1;
};
const [a = fn()] = [2]; // 2
//当右边不是undefined，左边的表达式不会执行，只有符合默认值条件是，表达式才会被执行
```

### 数组解构赋值的应用场景

1. arguments 类数组

2. NodeList 节点列表

3. 函数参数的解构赋值

4. 交换变量值，[x,y] = [y,x]; 因为等号左边是变量或常量，右边是值，所以这个等式可以完成变量交换运算

## 对象解构赋值

### 对象解构赋值原理

1. 模式（结构）匹配

2. 属性名相同的完成赋值

```js
//普通写法
const user = { name: "Tom", age: 18 };
//正常解构
const { name, age } = user; // name = user.name age = user.age
//对应的解构
const { name: name, age: age } = user;
//通过上面这种形式，我们可以看出，：左边获得解构对象里面的值，：右边是解构使用的变量名，所以我们可以这么做
//取别名
//将：右边的变量名修改，就可以与解构对象的属性名不一样，来使用解构出来的变量了
let { name: varName, age: varAge } = user; //varName = Tom varAge = 18
```

### 对象解构赋值的注意事项

1. 对象解构赋值的默认值，同数组解构

2. 将一个已经声明的变量用于解构赋值

```js
let x = 2;
//{x} = {x:1} 错误
//{x}被当作是作用域块，不会被当作对象
//处理办法和箭头函数处理单返回值对象的情况一样
//如果将一个已经声明的变量用于对象的解构赋值，整个赋值在圆括号中进行
({ x } = { x: 1 });
```

3. 可以取到继承的属性

```js
const { toString } = {}; // 取出Object的toString方法
```

### 对象解构赋值的应用

1. 函数参数的解构赋值

2. 复杂嵌套

## 其他数据类型的解构赋值

1. 字符串的解构赋值

- 同对象或者数组

2. 数值和布尔值的解构赋值

- 会将数值或者布尔值用包装类转换成对象，但因为转换后的对象内没有任何属性值，解构出来的变量值都是 undefined

3. undefined 和 null 的解构赋值

- 因为 undefined 和 null 没有对应的包装类，无法通过对它们转换成相应对象，所以程序会报错

# 对象字面量增强和函数参数的默认值

## 属性和方法的简洁表示法

- 对象字面量

```js
const obj = {
  name: "Tom",
  age: 18,
};
```

- 属性的简洁表示法

```js
const age = 18;
const name = "Tom";
//当键名和常量名或变量名一样的时候，可以只写一个
const obj = {
  name,
  age,
};
```

- 方法的简洁表示法

```js
const obj = {
  //通常方法
  //getName: function () {},
  //简洁方法
  //方法可以省略冒号和function关键字
  getName() {},
};
```

## 方括号语法

- 方括号语法的用法

  ```js
  //es6之前，需要对person对象进行声明才可以使用方括号语法
  const prop = "age";
  const person = {};
  person[prop] = 18;
  //现在方括号语法可以直接写在对象字面量中
  const uer = {
    [prop]: 18,
  };
  ```

- 方括号中间有什么

  - **\[值或者通过计算可以得到值的(表达式)\]**

- 方括号语法和点语法的区别

  - 点语法是方括号语法的特殊形式

  - 使用点语法的情况：**属性名是由数字、字母、下划线以及$构成，并且数字还不能打头的时候可以使用点语法**

## 函数参数的默认值

1. 认识函数参数的默认值

2. 函数参数默认值的基本用法

```js
// y 默认值是1
// 直接给参数赋值就是给参数设置默认值的方式
const multiply = (x, y = 1) => {
  return x * y;
};
```

- 关于函数参数默认值

  - 不传参或者明确的传递 undefined 作为参数，只有这两种情况下，默认值才会生效

  - 如果默认值是表达式、默认值表达式是惰性求值的

  - 设置默认值的小技巧

    - 函数参数的默认值，最好从参数列表的右边开始设置

## 函数参数默认值在实际中的应用情况

- 接收很多参数的时候，可能因为参数太多，造成函数难以使用，这个时候可以接受一个对象作为参数，再到函数参数位置，对对象解构，并设置默认值，这样就可以解决参数过多的问题

```JS
//传参设置默认值，并对传参对象设置默认值
const logUser = ({username="Tom", age=18, sex="male" } = {}) => {
  console.log(username,age,sex);
}
logUser();
logUser({username:"joy",age:19});
```
